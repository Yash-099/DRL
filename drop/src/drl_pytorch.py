# -*- coding: utf-8 -*-
"""drl_pytorch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bo4c1YpfMYmR7Vqh44Cx_5WuRG2947Ga

## Importing libraries
"""

import torch
from sklearn.model_selection import train_test_split
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
import cv2
import torch.optim as optim

# from google.colab import drive
# drive.mount('/content/drive')

"""## Loading Data"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/drl/new_dataset

# x_train,x_test,y_train,y_test = train_test_split(np.load('images_200.npy'),np.load('vel.npy'),test_size=0.1,random_state=42)

"""## Model"""

class ResBlock(nn.Module):
  def __init__(self,input_filter,output_filter):
    super(ResBlock,self).__init__()
    self.bn1 = nn.BatchNorm2d(input_filter)
    self.conv1 = nn.Conv2d(input_filter,output_filter,kernel_size=3,stride=2,padding=3)
    self.conv2 = nn.Conv2d(output_filter,output_filter,kernel_size=3)
    self.bn2 = nn.BatchNorm2d(output_filter)

  def forward(self,x):
    x = F.relu(self.bn1(x))
    x = self.conv1(x)
    x = F.relu(self.bn2(x))
    x = self.conv2(x)
    
    return x



class DRL_model(nn.Module):
  def __init__(self):
    super(DRL_model, self).__init__()
    self.conv1 = nn.Conv2d(1,32,kernel_size=5,stride=2)
    self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2)
    self.conv_res1 = nn.Conv2d(32,32,kernel_size=1,stride=2)
    self.res1 = ResBlock(32,32)
    self.conv_res2 = nn.Conv2d(32,64,kernel_size=1,stride=2)
    self.res2 = ResBlock(32,64)
    self.conv_res3 = nn.Conv2d(64,128,kernel_size=1,stride=2)
    self.res3 = ResBlock(64,128)
    self.fc1 = nn.Linear(4608,256)
    self.fc2 = nn.Linear(256,3)
    self.dropout = nn.Dropout(p=0.3)
  
  def forward(self,x):
    x = self.conv1(x)
    x = F.relu(self.maxpool(x))
    skip = self.conv_res1(x)
    x = self.res1(x)
    x = x + skip
    skip = self.conv_res2(x)
    x = self.res2(x)
    x = x+skip
    skip = self.conv_res3(x)
    x = self.res3(x)
    x=x+skip
    x = nn.Flatten()(x)
    x = self.dropout(x)
    x = self.fc1(x)
    x = self.fc2(x)
    return x



# from torchsummary import summary

"""## Training"""

# dronet_model = DRL_model()
# device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
# print(device)
# dronet_model.to(device)

# inp = torch.rand(1,1,200,200)
# y = dronet_model(inp.to(device))
# print(y.shape)

# def train(net, trainloader,valloader,criterion=nn.MSELoss(), NUM_EPOCHS=100):
#     optimizer = optim.Adam(net.parameters(), lr=learning_rate)
#     train_loss = []
#     val_loss = []
#     for epoch in range(NUM_EPOCHS):
#         print(epoch)
#         running_loss = 0.0
#         for img,label in trainloader:
#             optimizer.zero_grad()
#             pred_labels = net(img)
#             img = img.to(device)
#             loss = criterion(pred_labels,label)
#             loss.backward()
#             optimizer.step()
#             running_loss += loss.item()
        
#         loss = running_loss / len(trainloader)
#         train_loss.append(loss)
#         print('Epoch {} of {}, Train Loss: {:.5f}'.format(  
#             epoch+1, NUM_EPOCHS, loss))
#         for img,label in valloader:
#           img = img.to(device)
#           pred_labels = net(img)
#           loss = criterion(pred_labels,label)
#           running_loss += loss.item()
#         loss = running_loss/len(valloader)
#         print('Epoch {} of {}, val Loss: {:.5f}'.format(epoch+1, NUM_EPOCHS, loss))
#         val_loss.append(loss)
#     torch.save(net.state_dict(),'dronet'+'.pth')
#     return train_loss,val_loss

# class MyData():
#     def __init__(self,x,y):
#         self.size = len(x)
#         self.x = x
#         self.y = y
#     def __getitem__(self,index):
#         return (self.x[index],self.y[index])
#     def __len__(self):
#         return self.size

# from torch.utils.data import DataLoader
# x_train = torch.Tensor(x_train).reshape(x_train.shape[0],1,200,200).to(device)
# y_train = torch.Tensor(y_train).to(device)
# x_test = torch.Tensor(x_test).reshape(x_test.shape[0],1,200,200).to(device)
# y_test = torch.Tensor(y_test).to(device)
# BATCH_SIZE = 32

# trainloader = DataLoader(MyData(x_train,y_train),batch_size=BATCH_SIZE*2,shuffle=True)
# valloader = DataLoader(MyData(x_test,y_test),batch_size=BATCH_SIZE*2)
# learning_rate=0.001
# train_loss,val_loss = train(dronet_model,trainloader,valloader,NUM_EPOCHS=100)

# import matplotlib.pyplot as plt

# plt.plot(train_loss[20:])
# # plt.plot(val_loss[20:])
# plt.show()

# print(y_test[:10,:])
# # print(x_t[:10,:,:].shape)
# # DRL_model(x_train[:10,:,:,:])

# dronet_model.load_state_dict(torch.load('dronet.pth'))
# dronet_model(x_test[:10,:,:,:])